# Copyright 2019 The Exonum Team
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import shutil
import sys
import tempfile

from importlib import import_module
from contextlib import contextmanager
from typing import Any

from exonum_client.proofs import build_encoder_function
from exonum_client.protobuf_loader import ProtobufLoader
from exonum_client.protoc import Protoc
from exonum_launcher.instances import InstanceSpecLoader as BaseInstanceSpecLoader, InstanceSpecLoadError
from exonum_launcher.configuration import Instance

_PROTOBUF_SOURCES_FIELD_NAME = "sources"
_PYTHON_MODULES_NAME = "service_modules"
_MODULE_FILENAME_FIELD_NAME = "config_message_source"
_CONFIG_MESSAGE_FIELD_NAME = "message_name"
_DATA_FIELD_NAME = "data"
_FORMAT_FIELD_NAME = "format"
_VALUE_FIELD_NAME = "value"
_FROM_FILE_FIELD_NAME = "from_file"

try:
    from .proto.exonum.java import service_pb2
except (ModuleNotFoundError, ImportError):
    raise RuntimeError("Protobuf definition is not found")


class InstanceSpecLoader(BaseInstanceSpecLoader):
    """Instance spec loader for Java runtime
    Compiles and loads protobuf messages provided by user to serialize service
    configuration parameters.
    """

    def __init__(self):
        self.protoc = Protoc()

    def load_spec(self, _loader: ProtobufLoader, instance: Instance) -> bytes:
        return self.serialize_config_impl(instance.config, instance.name)

    def serialize_config(self, _loader: ProtobufLoader, instance: Instance, config: Any) -> bytes:
        return self.serialize_config_impl(config, instance.name)

    def serialize_config_impl(self, config: Any, instance_name: str) -> bytes:
        if config is None:
            raise InstanceSpecLoadError(f"No config found for instance: {instance_name}")

        if self.config_field_exists(config, _PROTOBUF_SOURCES_FIELD_NAME):
            return self.serialize_custom_config(config, instance_name)
        elif self.config_field_exists(config, _FORMAT_FIELD_NAME):
            return self.serialize_standard_config(config, instance_name)
        else:
            raise InstanceSpecLoadError(f"Invalid configuration of '{instance_name}', expected {_PROTOBUF_SOURCES_FIELD_NAME} or {_FORMAT_FIELD_NAME} field")

    def serialize_custom_config(self, config: Any, instance_name: str) -> bytes:
        self.assert_field_exists(config, instance_name, _MODULE_FILENAME_FIELD_NAME)
        self.assert_field_exists(config, instance_name, _DATA_FIELD_NAME)

        with self.prepare_tmp_dir() as tmp_dir:
            # Call protoc to compile proto sources:
            proto_output_dir = os.path.join(tmp_dir, _PYTHON_MODULES_NAME, instance_name)
            path_to_protobuf_sources = config[_PROTOBUF_SOURCES_FIELD_NAME]
            self.protoc.compile(path_to_protobuf_sources, proto_output_dir)

            # Import module generated by protobuf
            protobuf_filename = config[_MODULE_FILENAME_FIELD_NAME]
            module_name = self.filename_without_extension(protobuf_filename)
            service_module_path = f"{_PYTHON_MODULES_NAME}.{instance_name}.{module_name}_pb2"
            service_module = import_module(service_module_path)

            # Build encoder (serializer) for `Config` message from imported module
            config_class_name = config.get(_CONFIG_MESSAGE_FIELD_NAME, "Config")
            config_class = getattr(service_module, config_class_name)
            config_encoder = build_encoder_function(config_class)
            result = config_encoder(config[_DATA_FIELD_NAME])

            return result

    def serialize_standard_config(self, config: Any, instance_name: str) -> bytes:
        configuration_message = service_pb2.ServiceConfiguration()

        configuration_message.value = self.extract_value(config, instance_name)
        configuration_message.format = self.extract_format(config, instance_name)

        return configuration_message.SerializeToString()

    @staticmethod
    def extract_value(config: Any, instance_name: str) -> str:
        if InstanceSpecLoader.config_field_exists(config, _VALUE_FIELD_NAME):
            return config[_VALUE_FIELD_NAME]
        elif InstanceSpecLoader.config_field_exists(config, _FROM_FILE_FIELD_NAME):
            file_path = config[_FROM_FILE_FIELD_NAME]
            with open(file_path, 'r') as file:
                return file.read()
        else:
            raise InstanceSpecLoadError(f"Invalid configuration of {instance_name}, expected {_VALUE_FIELD_NAME} or {_FROM_FILE_FIELD_NAME} field")

    @staticmethod
    def extract_format(config: Any, instance_name: str) -> int:
        InstanceSpecLoader.assert_field_exists(config, instance_name, _FORMAT_FIELD_NAME)
        config_format = config[_FORMAT_FIELD_NAME]

        if config_format == "text":
            return service_pb2.ServiceConfiguration.Format.TEXT
        elif config_format == "json":
            return service_pb2.ServiceConfiguration.Format.JSON
        elif config_format == "properties":
            return service_pb2.ServiceConfiguration.Format.PROPERTIES
        else:
            raise InstanceSpecLoadError(f"Invalid config format ({config_format}) for instance '{instance_name}'")

    @staticmethod
    def filename_without_extension(protobuf_filename):
        return protobuf_filename.rsplit('.', 1)[0]

    @staticmethod
    def cleanup(tmp_dir) -> None:
        # Unload any previously loaded modules from other tests:
        loaded_modules = list(sys.modules.keys())
        for module in loaded_modules:
            if module.startswith(_PYTHON_MODULES_NAME):
                del sys.modules[module]
        sys.path.remove(tmp_dir)
        shutil.rmtree(tmp_dir)

    @contextmanager
    def prepare_tmp_dir(self) -> str:
        # Create a directory for temporary files:
        tmp_dir = tempfile.mkdtemp(prefix="exonum_java_")
        # Create a folder for Python files output:
        python_modules_path = os.path.join(tmp_dir, _PYTHON_MODULES_NAME)
        os.makedirs(python_modules_path)
        # Create __init__ file in the service_modules directory:
        init_file_path = os.path.join(python_modules_path, "__init__.py")
        open(init_file_path, "a").close()
        # Add a directory with service_modules into the Python path:
        sys.path.append(tmp_dir)
        try:
            yield tmp_dir
        finally:
            # Cleanup directory in case of exception
            self.cleanup(tmp_dir)

    @staticmethod
    def config_field_exists(config: Any, field_name: str) -> bool:
        return field_name in config

    @staticmethod
    def assert_field_exists(config: Any, instance_name: str, field_name: str) -> None:
        if not InstanceSpecLoader.config_field_exists(config, field_name):
            InstanceSpecLoader.raise_exception_field_not_found(instance_name, field_name)

    @staticmethod
    def raise_exception_field_not_found(instance_name: str, field_name: str) -> None:
        raise InstanceSpecLoadError(f"'{field_name}' field not found in instance '{instance_name}' config")
